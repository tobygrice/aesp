use crate::aes_lib::key::Key;
use crate::aes_lib::core::constants::{RCON, SBOX};
use crate::aes_lib::mode::encrypt_ecb_core;
use crate::aes_lib::error::Result;


pub struct Cipher {
    round_keys: Vec<[u8; 16]>,
}

impl Cipher {
    pub fn new(key: &Key) -> Self {
        Self { round_keys: expand_key(key) }
    }

    pub fn encrypt_ecb(&self, plaintext: &[u8]) -> Result<Vec<u8>> {
        encrypt_ecb_core(plaintext, &self.round_keys)
    }
}

pub(crate) fn expand_key(key: &Key) -> Vec<[u8; 16]> {
    let key = key.as_bytes();

    // Variable names match FIPS-197, NIST specification: https://doi.org/10.6028/NIST.FIPS.197-upd1
    // Nk   The number of 32-bit words comprising the key
    // Nr   The number of rounds. 10, 12, and 14 for AES-128, AES-192, and AES-256, respectively
    // w    The result of the key schedule, an array of words that form round keys
    // Nw   The total number of words generated by the key schedule (including initial key)
    let nk = key.len() / 4; // key size (in 4-byte words)
    let nr = nk + 6; // number of rounds = num of words in key + 6
    let nw = (nr + 1) * 4; // total number of words resulting from expansion

    // initialise w, vector comprising 4-byte words of round_keys
    let mut w: Vec<[u8; 4]> = vec![[0u8; 4]; nw];

    // first nk words of w are filled with the initial key
    for i in 0..key.len() {
        w[i / 4][i % 4] = key[i];
    }

    // initialise temp variable
    let mut temp = w[nk - 1];
    for i in nk..nw {
        if i % nk == 0 {
            // calculate rot_word, sub_word, and rcon on temp
            temp = [
                SBOX[temp[1] as usize] ^ RCON[i / nk],
                SBOX[temp[2] as usize],
                SBOX[temp[3] as usize],
                SBOX[temp[0] as usize],
            ];
        } else if nk == 8 && i % nk == 4 {
            // additional substitution on temp for AES-256 only
            temp = [
                SBOX[temp[0] as usize],
                SBOX[temp[1] as usize],
                SBOX[temp[2] as usize],
                SBOX[temp[3] as usize],
            ];
        }

        // w[i] = temp ⊕ w[i − Nk]
        w[i] = xor_words(&temp, &w[i - nk]);
        temp = w[i]; // update temp
    }

    // convert words vector into indexable round_keys vector
    let mut round_keys = vec![[0u8; 16]; nr + 1];
    for round in 0..=nr {
        let base = round * 4;
        for col in 0..4 {
            let word = w[base + col];
            for row in 0..4 {
                round_keys[round][col * 4 + row] = word[row];
            }
        }
    }
    
    round_keys
}

#[inline(always)]
fn xor_words(a: &[u8; 4], b: &[u8; 4]) -> [u8; 4] {
    [a[0] ^ b[0], a[1] ^ b[1], a[2] ^ b[2], a[3] ^ b[3]]
}