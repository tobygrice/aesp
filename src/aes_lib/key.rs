use rand::TryRngCore;
use rand::rngs::OsRng;

use crate::aes_lib::core::constants::{RCON, SBOX};
use crate::aes_lib::error::{Error, Result};
use crate::aes_lib::util::xor_words;

#[derive(Clone)]
enum KeyBytes {
    K128([u8; 16]),
    K192([u8; 24]),
    K256([u8; 32]),
}

/// Contains a valid AES key. Can be instantiated with a random key, or built from a slice 
/// of bytes that is 16, 24, or 32 bytes long.
/// A key object is required to instantiate a [Cipher](crate::aes_lib::cipher::Cipher).
#[derive(Clone)]
pub struct Key {
    bytes: KeyBytes,
}

impl Key {
    /// Generate a random 128-bit key. Returns Error if OsRng fails.
    pub fn rand_key_128() -> Result<Self> {
        let mut k = [0u8; 16];
        OsRng.try_fill_bytes(&mut k)?;
        Ok(Self {
            bytes: KeyBytes::K128(k),
        })
    }

    /// Generate a random 192-bit key. Returns Error if OsRng fails.
    pub fn rand_key_192() -> Result<Self> {
        let mut k = [0u8; 24];
        OsRng.try_fill_bytes(&mut k)?;
        Ok(Self {
            bytes: KeyBytes::K192(k),
        })
    }

    /// Generate a random 256-bit key. Returns Error if OsRng fails.
    pub fn rand_key_256() -> Result<Self> {
        let mut k = [0u8; 32];
        OsRng.try_fill_bytes(&mut k)?;
        Ok(Self {
            bytes: KeyBytes::K256(k),
        })
    }

    /// Attempts to build a key from a slice of bytes. Will return an InvalidKeyLength error 
    /// if the input slice is anything other than 16, 24, or 32 bytes long.
    pub fn try_from_slice(bytes: &[u8]) -> Result<Self> {
        Ok(match bytes.len() {
            16 => Self {
                bytes: KeyBytes::K128(bytes.try_into().unwrap()),
            },
            24 => Self {
                bytes: KeyBytes::K192(bytes.try_into().unwrap()),
            },
            32 => Self {
                bytes: KeyBytes::K256(bytes.try_into().unwrap()),
            },
            _ => return Err(Error::InvalidKeyLength { len: bytes.len() }),
        })
    }

    /// Returns a reference to the internal key, represented as an array of bytes.
    pub fn as_bytes(&self) -> &[u8] {
        match &self.bytes {
            KeyBytes::K128(k) => k,
            KeyBytes::K192(k) => k,
            KeyBytes::K256(k) => k,
        }
    }
}

/// AES key schedule. Returns a vector of 11, 13, and 15 round keys for AES-128, AES-192, 
/// and AES-256, respectively
pub(crate) fn expand_key(key: &Key) -> Vec<[u8; 16]> {
    let key = key.as_bytes();

    // Variable names match FIPS-197, NIST specification: https://doi.org/10.6028/NIST.FIPS.197-upd1
    // Nk   The number of 32-bit words comprising the key
    // Nr   The number of rounds. 10, 12, and 14 for AES-128, AES-192, and AES-256, respectively
    // w    The result of the key schedule, an array of words that form round keys
    // Nw   The total number of words generated by the key schedule (including initial key)
    let nk = key.len() / 4; // key size (in 4-byte words)
    let nr = nk + 6; // number of rounds = num of words in key + 6
    let nw = (nr + 1) * 4; // total number of words resulting from expansion

    // initialise w, vector comprising 4-byte words of round_keys
    let mut w: Vec<[u8; 4]> = vec![[0u8; 4]; nw];

    // first nk words of w are filled with the initial key
    for i in 0..key.len() {
        w[i / 4][i % 4] = key[i];
    }

    // initialise temp variable
    let mut temp = w[nk - 1];
    for i in nk..nw {
        if i % nk == 0 {
            // calculate rot_word, sub_word, and rcon on temp
            temp = [
                SBOX[temp[1] as usize] ^ RCON[i / nk],
                SBOX[temp[2] as usize],
                SBOX[temp[3] as usize],
                SBOX[temp[0] as usize],
            ];
        } else if nk == 8 && i % nk == 4 {
            // additional substitution on temp for AES-256 only
            temp = [
                SBOX[temp[0] as usize],
                SBOX[temp[1] as usize],
                SBOX[temp[2] as usize],
                SBOX[temp[3] as usize],
            ];
        }

        // w[i] = temp ⊕ w[i − Nk]
        w[i] = xor_words(&temp, &w[i - nk]);
        temp = w[i]; // update temp
    }

    // convert words vector into indexable round_keys vector
    let mut round_keys = vec![[0u8; 16]; nr + 1];
    for round in 0..=nr {
        let base = round * 4;
        for col in 0..4 {
            let word = w[base + col];
            for row in 0..4 {
                round_keys[round][col * 4 + row] = word[row];
            }
        }
    }

    round_keys
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn key_schedule_128() -> Result<()> {
        // run key schedule on 128 bit sample key from FIPS-197 Appendix A.1
        let key_128: [u8; 16] = [
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf,
            0x4f, 0x3c,
        ];

        let key = Key::try_from_slice(&key_128)?;
        let round_keys = expand_key(&key);
        let last = *round_keys.last().expect("round_keys should not be empty");

        // compare with last round key of sample schedule in A.1
        let expected: [u8; 16] = [
            0xd0, 0x14, 0xf9, 0xa8, 0xc9, 0xee, 0x25, 0x89, 0xe1, 0x3f, 0x0c, 0xc8, 0xb6, 0x63,
            0x0c, 0xa6,
        ];

        assert_eq!(last, expected);

        Ok(())
    }

    #[test]
    fn key_schedule_192() -> Result<()> {
        // run key schedule on 192 bit sample key from FIPS-197 Appendix A.2
        let key_192: [u8; 24] = [
            0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52, 0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90,
            0x79, 0xe5, 0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b,
        ];

        let key = Key::try_from_slice(&key_192)?;
        let round_keys = expand_key(&key);
        let last = *round_keys.last().expect("round_keys should not be empty");

        // compare with last round key of sample schedule in A.2
        let expected: [u8; 16] = [
            0xe9, 0x8b, 0xa0, 0x6f, 0x44, 0x8c, 0x77, 0x3c, 0x8e, 0xcc, 0x72, 0x04, 0x01, 0x00,
            0x22, 0x02,
        ];

        assert_eq!(last, expected);

        Ok(())
    }

    #[test]
    fn key_schedule_256() -> Result<()> {
        // run key schedule on 256 bit sample key from FIPS-197 Appendix A.3
        let key_256: [u8; 32] = [
            0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d,
            0x77, 0x81, 0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3,
            0x09, 0x14, 0xdf, 0xf4,
        ];

        let key = Key::try_from_slice(&key_256)?;
        let round_keys = expand_key(&key);
        let last = *round_keys.last().expect("round_keys should not be empty");

        // compare with last round key of sample schedule in A.3
        let expected: [u8; 16] = [
            0xfe, 0x48, 0x90, 0xd1, 0xe6, 0x18, 0x8d, 0x0b, 0x04, 0x6d, 0xf3, 0x44, 0x70, 0x6c,
            0x63, 0x1e,
        ];

        assert_eq!(last, expected);

        Ok(())
    }
}
